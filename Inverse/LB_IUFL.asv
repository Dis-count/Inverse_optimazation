% 这里有四组约束
% 第一个约束确保行内 r_ik (为1的最大值<为0 的最小值 )的大小关系

V_UFL = 28;   % 给定的最优值（目标值）

vi = [1 ; 1 ; 0;];

uik = [ 1; 0 ; 1 ; 
        0; 1 ; 0 ;  
        0; 0 ; 0 ;];

m = length(vi);  
n = length(uik)/m;    

x_0 = [vi;uik];
x0 =[x_0;x_0*(-1)];  %求解需要的double向量

% 给定的原问题Costs

FC    = [5; 6; 7;];

TC    = [11; 4; 8; 
         5; 7; 10; 
         19; 6; 3;];

Costs =[FC;TC];

V_0 = x_0'*Costs;    %  给定的最优解向量 对应的原成本矩阵的花费值

v1 = find(vi == 1);   % v1记录 vi=1 的横坐标 的 列向量   要分别找到vi为 0 或 1 的下标

v0 = find(vi == 0);

u1 = cell(v1,2);

ui = reshape(uik,3,3)';   % 转置 得到uik 的 解矩阵

for i = v1'  % v1 需要是行向量
    t=1;
    s = 0; %  用于记录 vi 中 rik==1 个数为1 的数量 
    
    u1{t,1} = i;  % 单元数组 第一列里面存放 vi为 1的坐标  
    u1{t,2} = find(ui(t,:) == 1);  %单元数组 第二列里面存放中 rik 对应行中 为1 的坐标   
    
    if length(find(ui(t,:) == 1))==1
        s=s+1;
        
        
    t=t+1;
end



u0 = cell(m-length(v1),2);  % 此处 重新定义 一个类似的单元数组 存放为0 的部分

for i = v0'  % v1 需要是行向量
    t=1;
    
    u1{t,1} = i;  % 单元数组 第一列里面存放 vi为 1的坐标  
    u1{t,2} = find(ui(t,:) == 0);  %单元数组 第二列里面存放中 rik 对应行中 为0 的坐标   
    
    t=t+1;
end


fi;

% 需要给出 vi 为1的下标  以及 为0 的下标

rik;

[h l] = max(reshape(TC,m,n), [], 2);   % 给出每一行的最大值列向量m 以及 下标向量l。  注意1 为每列， 2 为每行。

model.modelname = 'LB_Inv_UFL';
model.modelsense = 'min';

ncol = (m + m * n)*2 ;

model.lb    = zeros(ncol, 1);
model.ub    = inf(ncol, 1);

obj = ones(m + m * n ,1); 

model.obj = [obj; obj];   % norm-1 c-Costs  均为正

% model.vtype = [repmat('B', nPlants, 1); repmat('C', nPlants * nplayers, 1)];
% 
% Set data for constraints and matrix

nrow = m + n + 1  ; % 前两个约束加起来为 m 个；第三个约束有 n 个；
% 第四个约束有 vi=1 对应行中 rik==1 个数大于 1 的个数 加 一个等式

model.A     = sparse(nrow, ncol);

model.sense = [repmat('=', 1, 1); repmat('>', m^n, 1)];

% Production constraints   注意限制条件需要遍历  这一点非常复杂

model.A(1,:) = x0;

